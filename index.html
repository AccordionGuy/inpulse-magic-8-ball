<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Inpulse-magic-8-ball : A &quot;Magic 8-Ball&quot; app for the inPulse smartwatch" />
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Inpulse-magic-8-ball</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>The inPulse Magic 8-Ball</h1>
          <h2>A Beginner's Tutorial for Programming inPulse Smartwatch Apps</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/AccordionGuy/inpulse-magic-8-ball/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/AccordionGuy/inpulse-magic-8-ball/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/AccordionGuy/inpulse-magic-8-ball" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          
          <h1>Get Started Programming inPulse Smartwatch Apps</h1>
          <p><img src="images/inpulse_watches.jpg" alt="A pair of inPulse watches, one displaying the time, the other displaying the body of an email." /></p>        
          <p><strong>inPulse Magic 8-Ball</strong> is a tutorial for programmers who want to get started developing apps for the <a href="http://getinpulse.com">inPulse smartwatch</a> and who don't have very much experience with C or any experience programming embedded devices. In this tutorial, you'll:</p>
          <ul>
            <li>Download and set up a Linux virtual machine on your computer, in which you'll develop apps and run them in an inPulse watch simulator</li>
            <li>Get comfortable with the development environment and inPulse programming by writing a "Hello, world!" app</li>
            <li>Get a little more inPulse programming practice by writing a a <a href="http://en.wikipedia.org/wiki/Magic_8-Ball">"Magic 8-Ball"</a> app</li>
          </ul>

          <h2>What You'll Need</h2>
          <p>In order to go through this tutorial and build the inPulse Magic 8 Ball app, you'll need the following:</p>
          <p><img src="images/virtualbox_large_icon.jpg" style="float: right; margin: 0 0 10px 20px;" /><strong>A computer that can run Oracle VM VirtualBox 4.1.x.</strong> You'll develop the app and run it in the simulator, all from within a virtual Linux environment, and you'll need Oracle VM VirtualBox to run that virtual Linux environment. If you go to the <a href="http://www.oracle.com/technetwork/server-storage/virtualbox/downloads/index.html">Oracle VM VirtualBox downloads page</a>, you'll see all the operating systems it runs on: Windows 32- and 64-bit, Mac OS X, Solaris 10 and a fair number of Linux distributions (Debian, Fedora, Mandriva, openSUSE, Red Hat Enterprise Linux, SUSE and Ubuntu). Ideally, your computer should have at least 8GB of RAM.</p>
          <p><img src="images/the_c_programming_language.jpg" style="float: right; margin: 0 0 10px 20px;" /><strong>Some programming experience and a little familiarity with the C programming language.</strong> Don't let the fact that the inPulse is programmed in C scare you off: C programming can be pretty straightforward, and you'll find that many of the concepts from your preferred programming language will apply. If you use a programming language that's similar to C, such as C#, Java, JavaScript, Perl or PHP, you'll be at home with much of the C syntax. If you're new to C, there are many free online resources to help you get started, such as Zed Shaw's <a href="http://c.learncodethehardway.org/book/"><em>Learn C the Hard Way</em></a>.</p>
          <p>(In case you're wondering which flavor of C is used for inPulse programming, it's <a href="http://gcc.gnu.org/c99status.html">gcc's implementation of C99</a>.)</p>
          <p><strong>That's it!</strong> You won't even need an inPulse smartwatch. In this tutorial, you'll run all the apps in the simulator.</p>
          
          <h2>Setting Up the Development Environment</h2>
          <p>In order to develop apps for the inPulse smartwatch simulator, you'll need to do two things:</p>
          <ul>
            <li><strong>Download and install VirtualBox,</strong> which you'll use to run the virtual machine image.</li>
            <li><strong>Download and uncompress the virtual disk image,</strong> a virtual hard disk containing a complete Linux system that's already been set up with everything you need to start developing inPulse apps. This system will run in its own window as if it were another program running on your computer.</li>
          </ul>
        
          <h3>Download and Install VirtualBox</h3>
          <p>Go to the <a href="http://www.oracle.com/technetwork/server-storage/virtualbox/downloads/index.html">Oracle VM VirtualBox download page</a> , look under the section marked <strong>Oracle VM VirtualBox</strong> for the link for the installer for your computer's operating system and click on it. 
          
          <h4>If You're Running Mac OS</h4>
          <p><strong>If your operating system is Mac OS,</strong> the installer will come in a disk image (.dmg) file. Double-click the installer icon to open the disk image, which will create a virtual disk drive named <strong>VirtualBox</strong> on your desktop. The virtual disk drive should open automatically; if it doesn't, double-click it to see its contents. You should see something like this:</p>
          <p><img src="images/virtualbox_mac_installer_window.jpg"></p>
          <p><img src="images/virtualbox_icon.jpg" style="float: right; margin: 0 0 10px 20px;" />Double-click on the icon marked <strong>VirtualBox.mpkg</strong> to install Oracle VM VirtualBox. Once it's installed, open your <strong>Applications</strong> folder and double-click the VirtualBox icon to launch it.</p>
          
          <h4>If You're Running Windows</h4>
          <p><strong>If your operating system is Windows,</strong> the installer will come as an executable (.exe) file. Double-click on its icon to start the installer, then launch VirtualBox from the <strong>Start</strong> menu.</p>
          
          <h4>If You're Running Linux</h4>
          <p><strong>If your operating system is Linux,</strong> chances are you know what to do with the package format for your particular distribution and how to launch VirtualBox once it's installed. (I'll post a set of instructions for Ubuntu soon.)</p>
        
          <h3>Download and Uncompress the Virtual Disk Image</h3>
          <p><a href="https://s3.amazonaws.com/inpulse_simulator/simulator/inPulseSimulator.rar"><strong>Download the compressed virtual disk image, inPulseSimulator.rar</strong>,</a> then uncompress it. You might need to download a utility to uncompress .rar files, such as <a href="http://itunes.apple.com/app/the-unarchiver/id425424353?mt=12&ls=1">The Unarchiver</a> for Mac OS or <a href="http://www.win-rar.com/">WinRAR</a> or <a href="http://www.7-zip.org/">7-Zip</a> for Windows.</p>
          <p><img src="images/vm_icon.jpg" style="float: right; margin: 0 0 10px 20px;" />The uncompressed file will have the filename <strong>inPulseSimulator.vdi</strong>. Put it in whatever directory you use to store your development work.</p>
          
          <h3>Set Up the Virtual Machine</h3>
          <p><strong>If you haven't done so already, launch VirtualBox.</strong> You should see a window that looks like this:</p>
          <p><img src="images/virtualbox_01.jpg"></p>
          <p>Click <strong>New</strong>. This will start the <strong>New Virtual Machine Wizard</strong>, which walks you through the steps of setting up a virtual machine:</p>
          <p><img src="images/virtualbox_02.jpg"></p>
          <p>Click <strong>Continue</strong>, which takes you to the next step, where you specify what sort of operating system will run in the virtual machine:</p>
          <p><img src="images/virtualbox_03.jpg"></p>
          <p>Do the following:</p>
          <ul>
            <li>Give your virtual machine a name -- I chose <strong>inPulseDev</strong>, but you can name it however you like -- and enter it into the <strong>Name</strong> field.</li>
            <li>For the <strong>Operating System</strong>, select <strong>Linux</strong>.</li>
            <li>For the <strong>Version</strong>, select <strong>Linux 2.6</strong>.</li>
            <li>Click <strong>Continue</strong>.</li>
          </ul>
          <p>You'll be taken to the next step, where you specify the minimum amount of RAM to be allocated to the virtual machine.</p>
          <p><img src="images/virtualbox_04.jpg"></p>
          <p>On my computer, an 8GB MacBook Pro, I gave the virtual machine 4096MB (4GB) of RAM. This setting seems to work well for both the Mac OS host and Linux running in the virtual machine. You can experiment and see if you get acceptable performance from the virtual machine with less RAM.</p>
          <p>Once you've set the amount of RAM to be allocated to the virtual machine, click <strong>Continue</strong>. You'll be taken to the next step, where you set up a virtual hard disk.</p>
          <p><img src="images/virtualbox_05.jpg"></p>
          <p>We want the virtual machine to boot from this virtual disk, so make sure that <strong>Start-up Disk</strong> is checked. The virtual disk image you downloaded earlier is the one we want to use, so:</p>
          <ul>
            <li>Select <strong>Use existing hard disk</strong></li>
            <li>Click on the folder icon, use it to navigate to wherever you stored <strong>inPulseSimulator.vdi</strong> and select it.</li>
            <li>Click <strong>Continue</strong>.
          </ul>
          <p>You'll be taken to the summary page, where you can review the settings you chose:</p>
          <p><img src="images/virtualbox_06.jpg"></p>
          <p>The summary should list the following:</p>
          <ul>
            <li><strong>Name:</strong> <em>Whatever name you gave the virtual machine</em></li>
            <li><strong>OS Type:</strong> Linux 2.6</li>
            <li><strong>Base Memory:</strong> <em>Whatever you allocated -- mine says</em> 4096MB</li>
            <li><strong>Start-up Disk:</strong> inPulseSimulator.vdi (Normal, 10.00GB)</li>
          </ul>
          <p>Click the <strong>Create</strong> button. Your virtual machine will be created, and you'll be returned to the window you saw when you launched VirtualBox, with one notable difference:</p>
          <p><img src="images/virtualbox_07.jpg"></p>
          <p>In the left pane of the window, you'll see the virtual machine you just created.</p>
          
          <h3>Start the Virtual Machine</h3>
          <p>It's time to start the virtual machine to confirm that it works. Click on the virtual machine to make sure it's selected, then click <strong>Start</strong>. The virtual machine will start booting up, just like a hardware machine would, only more quickly. Dismiss any dialog boxes that may appear during the startup process.</p>
          <p>At some point, you should see the Ubuntu logo:</p>
          <p><img src="images/virtualbox_08.jpg"></p>
          <p>...and once the system has booted, you should see something like this:</p>
          <p><img src="images/virtualbox_09.jpg"></p>
          <p>The virtual disk image contains an older, out-of-date version of Ubuntu that isn't supported anymore. Don't let this bother you; this version is perfectly fine for running the development tools and the inPulse simulator.</p>
          <p>Dismiss the dialog box that says "Your Ubuntu release is not supported anymore" and close the Update Manager. You should now have a clear view of the desktop, which has four icons. One of the icons may be on top of another; rearrange the icons so that none of them overlap.</p>
          <p>The desktop should now look something like this:
          <p><img src="images/virtualbox_10.jpg"></p>
          <p><strong>Congratulations!</strong> You've set up the virtual machine and are now ready to start writing inPulse apps.</p>
          <p>Before we start developing apps, let me show you how to shut down the virtual machine.</p>
          
          <h3>Shut Down the Virtual Machine</h3>
          <p>Eventually, you'll want to shut down the virtual machine and work on something else (or get away from the computer entirely). You can do this by simply closing the virtual machine's window. The contents of the window will fade to grey and you'll be prompted with a dialog box:</p>
          <p><img src="images/virtualbox_11.jpg"></p>
          <p>You can choose any of these options; pick the one you prefer and click <strong>OK</strong> to shut down the virtual machine. I prefer the <strong>Save the machine state</strong> option, which "freezes the virtual machine in time". When I start it again, restores the virtual machine to the exact same state as when I "froze it in time", running programs and all.</p>
          
          <h2>Exploring the Development Environment</h2>
          <p><img src="images/explore_01.jpg" /></p>
          <p>You'll find four icons on the desktop of the development environment:</p>
          <p><img src="images/pulse_simulator_icon.jpg" style="float: left; margin: 0 20px 10px 0;"/><strong>pulse_simulator:</strong> A link to the directory containing the files you'll be using to develop apps, as well as some example code. The actual directory is located at <strong>/home/pulsesim/pulse_simulator</strong>. When you start developing inPulse apps, you work in this directory.</p>
          <p><img src="images/getting_started_icon.jpg" style="float: left; margin: 0 20px 10px 0;"/><strong>Getting Started:</strong> A link to inPulse's <a href="http://www.getinpulse.com/simulator/"><em>Getting Started with the inPulse Simulator</em></a> web page. That topic is also covered in this tutorial.</p>
          <p><img src="images/username_password_icon.jpg" style="float: left; margin: 0 20px 10px 0;"/><strong>username+password.txt:</strong> A text file containing the username and password of the <strong>pulsesim</strong> user, which you might need from time to time. The username and password are the same: <strong>pulsesim</strong>.</p>
          <p><img src="images/terminal_icon.jpg" style="float: left; margin: 0 20px 10px 0;"/><strong>Terminal:</strong> A link to the command-line <strong>Terminal</strong> program, which you'll use to compile and run your apps.</p>
          <p>Let's take a closer look at the contents of <strong>pulse_simulator</strong>:</p>
          <p><img src="images/explore_02.jpg" /></p>
          <p>Of these contents, the ones that of the most important to you in the short term are:</p>
          <ul>
            <li><strong>Makefile:</strong> Configures the <strong>make</strong> command, which you'll use to compile inPulse apps.</li>
            <li><strong>src:</strong> The directory for source files. The code you write goes here.</li>
            <li><strong>include:</strong> The directory for the header files that define inPulse's built-in functions and supported data types, which you'll need to <code>include</code> in your source code.</li>
            <li><strong>build:</strong> The directory where your app, once compiled, goes.</li>
            <li><strong>examples:</strong> A directory full of example code that you can use to learn more about inPulse programming.</li>
          </ul>
          
          <h2>Making Sure You Have the Latest Simulator</h2>
          <p>Before we do anything else, we need to make sure that the simulator is up to date. We'll do this by running the <strong>update_simulator</strong> script.</p>
          <p>Open the <strong>Terminal</strong> program. You can do this many ways; one way is to double-click on the <strong>Terminal</strong> icon on the desktop.</p>
          <p>Once <strong>Terminal</strong> is open, get a directory listing by entering the <code>ls</code> command. You should see the following:
<pre><code>pulsesim@ubuntu-desktop:~$ <span class="userinput">ls</span>
Desktop    examples.desktop  Public           update_simulator
Documents  Music             pulse_simulator  Videos
Downloads  Pictures          Templates</code></pre>
          <p>(<strong>Note:</strong> Any time we show you an example from a <strong>Terminal</strong> session, any commands you enter will be show in <code><span class="userinput">green</span></code>.)
          <p>Enter <code>./update_simulator</code> at the prompt. This will run a script that will download the latest versions of the simulator files into the <strong>pulse_simulator</strong> directory (your computer will have to be online). You should see the following:</p>
<pre><code>pulsesim@ubuntu-desktop:~$ <span class="userinput">./update_simulator</span> 
Downloading latest Pulse Simulator
--2012-07-20 15:47:23--  http://www.getinpulse.com/images/pulsesim/pulse_simulator.zip
Resolving www.getinpulse.com... 107.21.230.67
Connecting to www.getinpulse.com|107.21.230.67|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 817048 (798K) [application/zip]
Saving to: `pulse_simulator.zip'

100%[======================================>] 817,048      744K/s   in 1.1s    

2012-07-20 15:47:24 (744 KB/s) - `pulse_simulator.zip' saved [817048/817048]

Archive:  pulse_simulator.zip
replace pulse_simulator/Makefile? [y]es, [n]o, [A]ll, [N]one, [r]ename:</code></pre>
          <p>The script will pause at a prompt where it asks <code>replace pulse_simulator/Makefile? [y]es, [n]o, [A]ll, [N]one, [r]ename:</code>. Enter <code>A</code> for all, since we want all the files to be updated. You'll see a large list of messages announcing files being decompressed and put into their proper directories. When the messages stop and you are returned to the command prompt, the update is complete.</p>

          <h2>Compiling and Running the Sample App</h2>
          <p>Now that we've got the development environment set up, let's see the simulator in action! inPulse have set things up so that there's already a program ready to be compiled and run in the simulator.</p>
          <p>Change to the <strong>pulse_simulator</strong> directory by entering <code>cd pulse_simulator</code> at the command line. Then enter <code>make</code> to compile the code:</p>
<pre><code>pulsesim@ubuntu-desktop:~$ <span class="userinput">cd pulse_simulator/</span>
pulsesim@ubuntu-desktop:~/pulse_simulator$ <span class="userinput">make</span>
gcc -o build/pulse_app  -Iinclude -std=gnu99 -g -Wall lib/obj/main.o -Llib -D PULSE_SIMULATOR -lapp_common -lpulse_os -lpulse_protocol -lpulse_widgets -lgtk-x11-2.0 src/pulse_app.c
src/pulse_app.c: In function ‘main_app_handle_button_down’:
src/pulse_app.c:43: warning: implicit declaration of function ‘pulse_printf’
pulsesim@ubuntu-desktop:~/pulse_simulator$</code></pre>
          <p><strong>make</strong> uses the <strong>Makefile</strong> in this directory as instructions for compiling the source code, which is in the file <strong>pulse_app.c</strong>, which in turn is stored in the <strong>src</strong> directory. The resulting compiled file, <strong>pulse_app</strong>, is put into the <strong>build</strong> directory.</p>
          <p>(Don't worry about the warning issued by the compiler about the <code>implicit declaration of function ‘pulse_printf’</code>; it's the result of a little hack that makes development for the simulator a little easier.)</p>
          <p>We have a compiled app -- let's run it! Enter <code>build/pulse_app</code> at the prompt, and you should see this window appear:</p>
          <p><img src="images/simulator_01.jpg" /></p>
          <p>This app is called the <strong>Falling Box Demo</strong>. It draws a box that constantly falls from the top of the screen. When the box reaches the bottom of the screen, it's brought back to the top. Make a note of the size of the black area where the box is drawn: that's the area of the inPulse display, which is:</p>
          <ul>
            <li>96 pixels wide</li>
            <li>128 pixels high</li>
          </ul>
          <p>The inPulse has a single button on its right side. In the simulator, it's represented by the big button labelled <strong>Button</strong> on the right side of the window.</p> 
          <p>Click <strong>Button</strong>. You'll see something like this:</p>
          <p><img src="images/simulator_02.jpg" /></p>
          <p>The <strong>Button Down</strong> text appeared when you pressed down on the button, and the <strong>Button Up</strong> text appeared when you released it. This suggests that there's an event for each action, which you can use in your own apps.</p>
          <p>Look at <strong>Terminal</strong>. You'll see that it's displaying the following:</p>
<pre><code>Button Down
Button Up
</code></pre>
          <p>The function that prints text to the watch screen also prints to the terminal, which is handy for debugging.</p>
          <p>The simulator also has a menu bar, with two menus labelled <strong>Notifications</strong> and <strong>Hardware</strong>. For now, we're more interested in the menu bar itself, because it's used to simulate the inPulse vibrate function:</p>
          <ul>
            <li><strong>When vibrate is off,</strong> the menu bar is brown.</li>
            <li><strong>When vibrate is on,</strong> the menu bar is blue.</li>
          </ul>
          <p>Once you're done trying out the sample app, stop it. You can do this by either:</p>
          <ul>
            <li>Clicking on the simulator's "close window" button</li>
            <li>Typing <strong>control-C</strong> in <strong>Terminal</strong></li>
          </ul>
            
          <h2>Your First inPulse App: "Hello, World!"</h2>
          <h3>Getting the Code</h3>
          <p>We're going to start coding from here on in. You can type in the code yourself or copy and paste it, and if you want to download it, it's all available on <a href="https://github.com/AccordionGuy/inpulse-magic-8-ball">this GitHub source page</a>.</p>
          
          <h3>The Skeleton</h3>
          <p>For all the exercises in this tutorial, we're going to be working on the <strong>pulse_app.c</strong> file, which is located in the <strong>src</strong> directory of <strong>pulse_simulator</strong>.</p>
          <p>Open <strong>pulse_app.c</strong> with the editor of your choice. If you prefer to use a GUI-based editor, navigate to <strong>pulse_app.c</strong> and double-click it. This will open the file in gEdit, Ubuntu's default GUI editor.</p>
          <p><strong>pulse_app.c</strong> currently contains the code for the demo app we just ran. This code also exists in the <strong>examples/api_examples</strong> directory, in the file titled <strong>falling_box_using_main_loop.c</strong>, so we can overwrite it without worry. Since the <strong>Makefile</strong> is already set up to compile <strong>pulse_app.c</strong>, it's easiest just to use this file.</p>
          <p>Select all the code in <strong>pulse_app.c</strong> and delete it. Copy the following code, paste it into <strong>pulse_app.c</strong> and save it:</p>
          <p><a href="https://github.com/AccordionGuy/inpulse-magic-8-ball/blob/master/hello_world_1.c"><strong><em>hello_world_1.c</em></strong></a></p>
<pre><code>//
// Hello, World!
// =============
//
// A simple tutorial app that demonstrates displaying the time
// and other text on the inPulse smartwatch screen,
// as well as responding to button events.
//
// Since this is a tutorial app, it's a little more heavily
// commented than your typical code.


#include &lt;stdint.h&gt;

// Headers we'll need to program inPulse apps.
// - pulse_os.h gives us access to the inPulse API functions,
//   from telling the time to drawing on the screen to controlling
//   vibration and so on.
// - pulse_types.h provides data types that we use when using
//   the inPulse API.
#include &lt;pulse_os.h&gt;
#include &lt;pulse_types.h&gt;


// inPulse Event Handlers
// ======================
// These routines are called in response to inPulse watch events,
// such as the watch booting up, the user pressing and releasing
// the button and so on.

// main_app_init is called once: after the watch has booted up, its
// OS has been loaded and when the app is starting up. 
// Use this to initialize your app.
void main_app_init()
{

}

// main_app_handle_button_down is called every time the user presses down
// on the watch button.
void main_app_handle_button_down()
{

}

// main_app_handle_button_up is called every time the user releases the
// watch button after having pressed it.
void main_app_handle_button_up()
{

}

// main_app_loop is a function that gets called regularly and frequently.
// Use this for operations that your app will perform on a regular basis.
// No blocking calls are allowed in this function; any call that blocks
// for over 5 seconds will cause the inPulse watchdog timer to start and
// reset the watch.
void main_app_loop()
{

}

// main_app_handle_doz is called whenever the processor is about to go into
// sleep mode to conserve power. Use this to do any "housekeeping" before the
// watch goes to sleep.
// The sleep functionality is scheduled with pulse_update_power_down_timer.
void main_app_handle_doz()
{

}

// main_app_handle_hardware_update is called whenever certain hardware events
// take place, such as Bluetooth connection/disconnetion and changes in the
// "battery charging" status.
void main_app_handle_hardware_update(enum PulseHardwareEvent event)
{

}</code></pre>
          <p>This is the <em>skeleton</em> -- a little framework that we'll flesh out throughout this exercise. Read the comments in the code, as they explain a lot.</p>
          <p>Switch to <strong>Terminal</strong>, compile the app with <strong>make</strong> and then run it. Your terminal window should look like this:</p>
<pre><code>pulsesim@ubuntu-desktop:~/pulse_simulator$ <span class="userinput">make</span>
gcc -o build/pulse_app  -Iinclude -std=gnu99 -g -Wall lib/obj/main.o -Llib -D PULSE_SIMULATOR -lapp_common -lpulse_os -lpulse_protocol -lpulse_widgets -lgtk-x11-2.0 src/pulse_app.c
pulsesim@ubuntu-desktop:~/pulse_simulator$ <span class="userinput">./build/pulse_app</span> 
No resources read from ../resources/inpulse_resources.bin
</code></pre>
          <p>The simulator should be running and look like this:</p>
          <p><img src="images/simulator_03.jpg" /></p>
          <p>It runs, but since it's just a skeleton without any functioning code within, it's not doing anything you can see. Stop the app (either by closing the simulator window or typing <strong>control-C</strong> in the terminal).</p>
          
          <h3>Displaying "Hello World" on the Screen</h3>
          <p>Just as with command-line desktop apps written in C, the <code>printf</code> function for inPulse sends text to <strong>stdout</strong>, or "standard output". In this particular case, anything sent to <strong>stdout</strong> is displayed in two places:</p>
          <ul>
            <li>The simulator display</li>
            <li>The console</li>
          </ul>
          <p>To show the message <strong>Hello, world!</strong> on the simulator display, the following line of code needs to be executed:</p>
<pre><code>printf("Hello, world!\n");</code></pre>
          <p>That's the easy part. The question is now "Where do we put that line of code?" In a desktop C program, you'd put it in the <code>main</code> function, but our inPulse app skeleton (and inPulse apps in general) doesn't have one.</p>
          <p>The functions in our skeleton where we <em>could</em> place our <code>printf</code> statement are:</p>
          <ul>
            <li><code>main_app_init</code>: Called only once, when the watch boots up, the OS has been loaded and the app is starting up.</li>
            <li><code>main_app_handle_button_down</code>: Called whenever the user presses <em>down</em> on the watch button.</li>
            <li><code>main_app_handle_button_up</code>: Called whenever the user, after having pressed down on the watch button, releases it.</li>
            <li><code>main_app_loop</code>: Called regularly as the watch continues to operate.</li>
            <li><code>main_app_handle_doz</code>: Called at the time right before the watch is about to go into power-conserving sleep mode.</li>
            <li><code>main_app_handle_hardware_update</code>: Called whenever certain hardware events, such as Bluetooth connection/disconnection or changes in battery charging status take place. </li>
          </ul>
          <p><code>main_app_init</code> is called once, when the app starts up, so it sounds like a good candidate to place that line of code. Your code skeleton should look like this now:</p>
          <p><a href="https://github.com/AccordionGuy/inpulse-magic-8-ball/blob/master/hello_world_2.c"><strong><em>hello_world_2.c</em></strong></a></p>
<pre><code>//
// Hello, World!
// =============
//
// A simple tutorial app that demonstrates displaying the time
// and other text on the inPulse smartwatch screen,
// as well as responding to button events.
//
// Since this is a tutorial app, it's a little more heavily
// commented than your typical code.


include &lt;stdint.h&gt;

// Headers we'll need to program inPulse apps.
// - pulse_os.h gives us access to the inPulse API functions,
//   from telling the time to drawing on the screen to controlling
//   vibration and so on.
// - pulse_types.h provides data types that we use when using
//   the inPulse API.
#include &lt;pulse_os.h&gt;
#include &lt;pulse_types.h&gt;


// inPulse Event Handlers
// ======================
// These routines are called in response to inPulse watch events,
// such as the watch booting up, the user pressing and releasing
// the button and so on.

// main_app_init is called once: after the watch has booted up, its
// OS has been loaded and when the app is starting up. 
// Use this to initialize your app.
void main_app_init()
{
    printf("Hello, world!");
}

// main_app_handle_button_down is called every time the user presses down
// on the watch button.
void main_app_handle_button_down()
{

}

// main_app_handle_button_up is called every time the user releases the
// watch button after having pressed it.
void main_app_handle_button_up()
{

}

// main_app_loop is a function that gets called regularly and frequently.
// Use this for operations that your app will perform on a regular basis.
// No blocking calls are allowed in this function; any call that blocks
// for over 5 seconds will cause the inPulse watchdog timer to start and
// reset the watch.
void main_app_loop()
{

}

// main_app_handle_doz is called whenever the processor is about to go into
// sleep mode to conserve power. Use this to do any "housekeeping" before the
// watch goes to sleep.
// The sleep functionality is scheduled with pulse_update_power_down_timer.
void main_app_handle_doz()
{

}

// main_app_handle_hardware_update is called whenever certain hardware events
// take place, such as Bluetooth connection/disconnetion and changes in the
// "battery charging" status.
void main_app_handle_hardware_update(enum PulseHardwareEvent event)
{

}</code></pre>
          <p>(Yes, that's a lot of code to show for a one-line change, but I thought it might be reassuring to see the whole thing, at least for your first attempt at inPulse code.)</p>
          <p>Switch to <strong>Terminal</strong>, compile the app with <strong>make</strong> and then run it. Your terminal window should look like this:</p>
<pre><code>pulsesim@ubuntu-desktop:~/pulse_simulator$ <span class="userinput">make</span>
gcc -o build/pulse_app  -Iinclude -std=gnu99 -g -Wall lib/obj/main.o -Llib -D PULSE_SIMULATOR -lapp_common -lpulse_os -lpulse_protocol -lpulse_widgets -lgtk-x11-2.0 src/pulse_app.c
src/pulse_app.c: In function ‘main_app_init’:
src/pulse_app.c:41: warning: implicit declaration of function ‘pulse_printf’
pulsesim@ubuntu-desktop:~/pulse_simulator$ <span class="userinput">./build/pulse_app</span>
No resources read from ../resources/inpulse_resources.bin
Hello, world!
</code></pre>
          <p>Note that the text <code>Hello, world!</code> appears in the terminal. Any output created by <code>printf</code> will appear on both the simulator display and in the terminal.</p>
          <p>The simulator should be running and look like this:</p>
          <p><img src="images/simulator_04.jpg"></p>
          
          <h3>Responding to Button Presses</h3>
          <p>Let's make a couple of changes to the current app:</p>
          <ul>
            <li>When the user presses down on the button, let's have the watch display the text <strong>Button goes down...</strong></li>
            <li>When the user releases the button, the watch should display the text <strong>...button goes up!</strong></li>
          </ul>
          <p>To do this, we'll add a couple of <code>printf</code> statements: one to <code>main_app_handle_button_down</code> and one to <code>main_app_handle_button_up</code>. Here's how the code should look:</p>
          <p><a href="https://github.com/AccordionGuy/inpulse-magic-8-ball/blob/master/hello_world_3.c"><strong><em>hello_world_3.c</em></strong></a></p>
<pre><code>//
// Hello, World!
// =============
//
// A simple tutorial app that demonstrates displaying the time
// and other text on the inPulse smartwatch screen,
// as well as responding to button events.
//
// Since this is a tutorial app, it's a little more heavily
// commented than your typical code.


#include &lt;stdint.h&gt;

// Headers we'll need to program inPulse apps.
// - pulse_os.h gives us access to the inPulse API functions,
//   from telling the time to drawing on the screen to controlling
//   vibration and so on.
// - pulse_types.h provides data types that we use when using
//   the inPulse API.
#include &lt;pulse_os.h&gt;
#include &lt;pulse_types.h&gt;


// inPulse Event Handlers
// ======================
// These routines are called in response to inPulse watch events,
// such as the watch booting up, the user pressing and releasing
// the button and so on.

// main_app_init is called once: after the watch has booted up, its
// OS has been loaded and when the app is starting up. 
// Use this to initialize your app.
void main_app_init()
{
    printf("Hello, world!\n");
}

// main_app_handle_button_down is called every time the user presses down
// on the watch button.
void main_app_handle_button_down()
{
    printf("Button goes down...\n");
}

// main_app_handle_button_up is called every time the user releases the
// watch button after having pressed it.
void main_app_handle_button_up()
{
    printf("...button goes up!\n");
}

// main_app_loop is a function that gets called regularly and frequently.
// Use this for operations that your app will perform on a regular basis.
// No blocking calls are allowed in this function; any call that blocks
// for over 5 seconds will cause the inPulse watchdog timer to start and
// reset the watch.
void main_app_loop()
{

}

// main_app_handle_doz is called whenever the processor is about to go into
// sleep mode to conserve power. Use this to do any "housekeeping" before the
// watch goes to sleep.
// The sleep functionality is scheduled with pulse_update_power_down_timer.
void main_app_handle_doz()
{

}

// main_app_handle_hardware_update is called whenever certain hardware events
// take place, such as Bluetooth connection/disconnetion and changes in the
// "battery charging" status.
void main_app_handle_hardware_update(enum PulseHardwareEvent event)
{

}</code></pre>
          <p>Switch to <strong>Terminal</strong>, compile the app with <strong>make</strong> and then run it. Your terminal window should look like this:</p>
<pre><code>pulsesim@ubuntu-desktop:~/pulse_simulator$ <span class="userinput">make</span>
gcc -o build/pulse_app  -Iinclude -std=gnu99 -g -Wall lib/obj/main.o -Llib -D PULSE_SIMULATOR -lapp_common -lpulse_os -lpulse_protocol -lpulse_widgets -lgtk-x11-2.0 src/pulse_app.c
src/pulse_app.c: In function ‘main_app_init’:
src/pulse_app.c:42: warning: implicit declaration of function ‘pulse_printf’
pulsesim@ubuntu-desktop:~/pulse_simulator$ <span class="userinput">./build/pulse_app</span>
No resources read from ../resources/inpulse_resources.bin
Hello, world!
</code></pre>
          <p>The simulator will run and initially look like this:</p>
          <p><img src="images/simulator_04.jpg"></p>
          <p>If you press and release <strong>Button</strong>, it should look like this:</p>
          <p><img src="images/simulator_05.jpg"></p>
          <p>If you press and release <strong>Button</strong> more times, the output text will reach past the bottom of the display. When that happens, the text doesn't scroll; instead, the display is cleared, and any remaining text is put at the top:</p>
          <p><img src="images/simulator_06.jpg"></p>
          
          <h3>Telling the Time and Clearing the Display</h3>
          <p>The inPulse is a smart<em>watch</em>, which implies that its users will use it to tell the time. It uses its own type (defined in <strong>&lt;pulse_types.h&gt;</strong>) -- a <code>struct</code> called <code>pulse_time_tm</code> -- to represent time and date data. Here are its members:</p>
          <table width="80%" border="4" cellspacing="1" cellpadding="3">
            <tr>
              <th width="25%">Member</th>
              <th width="25%">Type</th>
              <th width="50%">Description</th>
            </tr>
            <tr>
              <td><code>tm_sec</code></td>
              <td><code>int32_t</code></td>
              <td>Seconds [0 - 60]</td>
            </tr>
            <tr>
              <td><code>tm_min</code></td>
              <td><code>int32_t</code></td>
              <td>Minutes [0 - 59]</td>
            </tr>
            <tr>
              <td><code>tm_hour</code></td>
              <td><code>int32_t</code></td>
              <td>Hour [0 - 23]</td>
            </tr>
            <tr>
              <td><code>tm_mday</code></td>
              <td><code>int32_t</code></td>
              <td>Day of the month [1 - 31]</td>
            </tr>
            <tr>
              <td><code>tm_mon</code></td>
              <td><code>int32_t</code></td>
              <td>Month [0 - 11, where 0 is January]</td>
            </tr>
            <tr>
              <td><code>tm_year</code></td>
              <td><code>int32_t</code></td>
              <td>
                <p>Year.</p>
                </p>Note that this is different from the way the year is expressed in the <code>tm</code> structure of the <a href="http://www.cplusplus.com/reference/clibrary/ctime/">standard <strong>&lt;time.h&gt;</strong> or <strong>&lt;ctime&gt;</strong> library</a>, where this value is expressed as years since 1900.</p>
              </td>
            </tr>
            <tr>
              <td><code>tm_wday</code></td>
              <td><code>int32_t</code></td>
              <td>Day of the week [0 - 6, where 0 is Sunday]</td>
            </tr>
            <tr>
              <td><code>tm_yday</code></td>
              <td><code>int32_t</code></td>
              <td>Day of the year [0 - 365, where 0 is January 1]</td>
            </tr>
            <tr>
              <td><code>tm_isdat</code></td>
              <td><code>int32_t</code></td>
              <td><strong><em>(Unused)</em></strong> Daylight saving time status</td>
            </tr>
          </table>
          <br />
          <p>To get the current time and date, pass the address of a variable of type <code>pulse_time_tm</code> to the API function <code>pulse_get_time_date</code>. When the function returns, you can extract the time and date information from the <code>pulse_time_tm</code> variable. Here's an example:</p>
<pre><code>struct pulse_time_tm current_time;
pulse_get_time_date(&amp;current_time);
printf("The time is\n%d:%0.2d:%0.2d\n", 
       current_time.tm_hour,
       current_time.tm_min,
       current_time.tm_sec);</code></pre>
          <p>Clearing the display is pretty simple: a call to the API function <code>pulse_blank_canvas</code> does just that.</p>
          <p>We can take the current "Hello, world!" code and with very little work, change it into an app that does the following:</p>
          <ul>
            <li>Display <strong>Hello, world!</strong> when it starts up</li>
            <li>Clear the display when the button is pushed down</li>
            <li>Display the current time when the button is released</li>
          </ul>
          <p>Here's what the code looks like:</p>
          <p><a href="https://github.com/AccordionGuy/inpulse-magic-8-ball/blob/master/hello_world_4.c"><strong><em>hello_world_4.c</em></strong></a></p>
<pre><code>//
// Hello, World!
// =============
//
// A simple tutorial app that demonstrates displaying the time
// and other text on the inPulse smartwatch screen,
// as well as responding to button events.
//
// Since this is a tutorial app, it's a little more heavily
// commented than your typical code.


#include &lt;stdint.h&gt;

// Headers we'll need to program inPulse apps.
// - pulse_os.h gives us access to the inPulse API functions,
//   from telling the time to drawing on the screen to controlling
//   vibration and so on.
// - pulse_types.h provides data types that we use when using
//   the inPulse API.
#include &lt;pulse_os.h&gt;
#include &lt;pulse_types.h&gt;


struct pulse_time_tm current_time;


// inPulse Event Handlers
// ======================
// These routines are called in response to inPulse watch events,
// such as the watch booting up, the user pressing and releasing
// the button and so on.

// main_app_init is called once: after the watch has booted up, its
// OS has been loaded and when the app is starting up. 
// Use this to initialize your app.
void main_app_init()
{
    printf("Hello, world!\n");
}

// main_app_handle_button_down is called every time the user presses down
// on the watch button.
void main_app_handle_button_down()
{
    pulse_blank_canvas();
}

// main_app_handle_button_up is called every time the user releases the
// watch button after having pressed it.
void main_app_handle_button_up()
{
    pulse_get_time_date(amp;urrent_time);
    printf("The time is\n%d:%0.2d:%0.2d\n", 
           current_time.tm_hour,
           current_time.tm_min,
           current_time.tm_sec);
}

// main_app_loop is a function that gets called regularly and frequently.
// Use this for operations that your app will perform on a regular basis.
// No blocking calls are allowed in this function; any call that blocks
// for over 5 seconds will cause the inPulse watchdog timer to start and
// reset the watch.
void main_app_loop()
{

}

// main_app_handle_doz is called whenever the processor is about to go into
// sleep mode to conserve power. Use this to do any "housekeeping" before the
// watch goes to sleep.
// The sleep functionality is scheduled with pulse_update_power_down_timer.
void main_app_handle_doz()
{

}

// main_app_handle_hardware_update is called whenever certain hardware events
// take place, such as Bluetooth connection/disconnetion and changes in the
// "battery charging" status.
void main_app_handle_hardware_update(enum PulseHardwareEvent event)
{

}</code></pre>
          <p>Switch to <strong>Terminal</strong>, compile the app with <strong>make</strong> and then run it. Your terminal window should look like this:</p>
<pre><code>pulsesim@ubuntu-desktop:~/pulse_simulator$ <span class="userinput">make</span>
gcc -o build/pulse_app  -Iinclude -std=gnu99 -g -Wall lib/obj/main.o -Llib -D PULSE_SIMULATOR -lapp_common -lpulse_os -lpulse_protocol -lpulse_widgets -lgtk-x11-2.0 src/pulse_app.c
src/pulse_app.c: In function ‘main_app_init’:
src/pulse_app.c:45: warning: implicit declaration of function ‘pulse_printf’
pulsesim@ubuntu-desktop:~/pulse_simulator$ <span class="userinput">./build/pulse_app</span>
No resources read from ../resources/inpulse_resources.bin
Hello, world!
</code></pre>
          <p>Here's what the simulator looks like when the app starts:</p>
          <p><img src="images/simulator_04.jpg" /></p>
          <p>Here's what it looks like while the user presses or holds down <strong>Button</strong>:</p>
          <p><img src="images/simulator_03.jpg" /></p>
          <p>And here's what it looks like when the user releases <strong>Button</strong>:</p>
          <p><img src="images/simulator_07.jpg" /></p>
          
          <h2>Let's Make That Magic 8-Ball App</h2>
          
          <h3>A Leaner Skeleton</h3>
          <p>Let's start with some leaner skeleton code -- it's the same as the skeleton code from above, but without all the comments:</p>
          <p><a href="https://github.com/AccordionGuy/inpulse-magic-8-ball/blob/master/lean_inpulse_skeleton.c"><strong><em>lean_inpulse_skeleton.c</em></strong></a></p>
<pre><code>//
// Lean inPulse Skeleton
// =====================
//
// A skeleton for inPulse smartwatch apps.

#include &lt;stdint.h&gt;

#include &lt;pulse_os.h&gt;
#include &lt;pulse_types.h&gt;


// inPulse Event Handlers
// ======================

void main_app_init()
{

}

void main_app_handle_button_down()
{

}

void main_app_handle_button_up()
{

}

void main_app_loop()
{

}

void main_app_handle_doz()
{

}

void main_app_handle_hardware_update(enum PulseHardwareEvent event)
{

}
</code></pre>
          
          <h3>The <code>main_app_loop</code> Handler</h3>
          <p>The <code>main_app_loop</code> handler is called regularly and often. If you're familiar with event-driven programming, think of it as being similar to a method called every time you go through the event loop. If you're familiar with game programming, think of it as being like a method called every time you go through the game loop.</p>
          <p>Here's a little code that shows <code>main_app_loop</code> in action:</p>
          <p><a href="https://github.com/AccordionGuy/inpulse-magic-8-ball/blob/master/main_app_loop_demo.c"><strong><em>main_app_loop_demo.c</em></strong></a></p>
<pre><code>//
// Main App Loop Demo
// ==================
//
// An app that demonstrates the inPulse API's
// main_app_loop event handler.

#include &lt;stdint.h&gt;

#include &lt;pulse_os.h&gt;
#include &lt;pulse_types.h&gt;


struct pulse_time_tm current_time;


// inPulse Event Handlers
// ======================

void main_app_init()
{

}

void main_app_handle_button_down()
{

}

void main_app_handle_button_up()
{

}

void main_app_loop()
{
    pulse_get_time_date(&amp;current_time);
    printf("The time is\n%d:%0.2d:%0.2d\n", 
           current_time.tm_hour,
           current_time.tm_min,
           current_time.tm_sec);
}

void main_app_handle_doz()
{

}

void main_app_handle_hardware_update(enum PulseHardwareEvent event)
{

}
</code></pre>
          <p>When you run the app, this is what the simulator looks like:</p>
          <p><img src="images/simulator_08.jpg" /></p>
          <p>Here's what the output to the console looks like on my computer (an early 2011-era MacBook Pro):</p>
<pre><code>The time is
3:54:13
The time is
3:54:13
The time is
3:54:13
The time is
3:54:13
The time is
3:54:13
The time is
3:54:14
The time is
3:54:14
The time is
3:54:14
The time is
3:54:14
The time is
3:54:14
The time is
3:54:15
The time is
3:54:15
The time is
3:54:15
The time is
3:54:15
The time is
3:54:15
The time is
3:54:16
The time is
3:54:16
The time is
3:54:16
The time is
3:54:16
The time is
3:54:16
</code></pre>
          <p>On my system, <code>main_app_loop</code> seems to get called about 5 times a second. I don't know anything about how the simulator was programmed, so it's possible that the rate at which <code>mail_app_loop</code> gets called may vary with the speed of your system.</p> 
          <p>At the very least, you can count on it getting called a handful of times each second. This means you can use it for:</p>
          <ul>
            <li>"Listener"-type operations, where the code constantly checks to see if some condition has been met</li>
            <li>"Clockwork"-type operations, where the code needs to perform some kind of regular update, such as an animation</li>
          </ul>
          <p>In the next example, we'll look at a "listener"-type use of <code>main_app_loop</code>.</p>

          <h3>The Main Timer (or: "How Long Have I Been Up?")</h3>
          <p>The main timer keeps track of the number of milliseconds since the watch (or simulator) has booted up. It continues to do so until the watch goes into sleep mode. When the watch wakes up, it resets to zero and starts counting the milliseconds since it woke up.</p>
          <p>You can get the main timer's count of milliseconds with the API function <code>pulse_get_millis</code>, which returns a value of type <code>uint32_t</code>.</p>
          <p>Here's an app that makes use of <code>pulse_get_millis</code>. Here's what it does:</p>
          <ul>
            <li>Display <strong>Starting app!</strong> on startup, along with the main timer's value at that time.</li>
            <li>Every 5 seconds from then on, it clears the display, announces that 5 seconds have passed and shows both the main timer's value at that time as well as the interval (in milliseconds) between this announcement and the previous one.</li>
          </ul>
          <p><a href="https://github.com/AccordionGuy/inpulse-magic-8-ball/blob/master/main_timer_experiment.c"><strong><em>main_timer_experiment.c</em></strong></a></p>
<pre><code>//
// Main Timer Experiment
// =====================
//
// An app written to show the use of the inPulse API's
// pulse_get_millis and main_app_loop functions
// in tandem.

#include &lt;stdint.h&gt;

#include &lt;pulse_os.h&gt;
#include &lt;pulse_types.h&gt;


#define INTERVAL_LENGTH_MS 5000
uint32_t start_interval_ms;
uint32_t now_ms;


// inPulse Event Handlers
// ======================

void main_app_init()
{
    start_interval_ms = pulse_get_millis();
    printf("Starting app!\n");
    printf("Timer: %d\n", start_interval_ms);
}

void main_app_handle_button_down()
{

}

void main_app_handle_button_up()
{

}

void main_app_loop()
{
    now_ms = pulse_get_millis();
    if (now_ms - start_interval_ms > INTERVAL_LENGTH_MS) {
        pulse_blank_canvas();
        printf("5 seconds have\npassed!\n");
        printf("Timer: %d\n", now_ms);
        printf("Actual interval:%d\n", now_ms - start_interval_ms);
        start_interval_ms = pulse_get_millis();
    }
}

void main_app_handle_doz()
{

}

void main_app_handle_hardware_update(enum PulseHardwareEvent event)
{

}
</code></pre>
          <p>Here's the app's initial output:</p>
          <p><img src="images/simulator_09.jpg" /></p>
          <p>Here it is, about five seconds later:</p>
          <p><img src="images/simulator_10.jpg" /></p>
          <p>Here it is again, a few five-second intervals later:
          <p><img src="images/simulator_11.jpg" /></p>
          <p>Here's a capture of the app's console output:
<pre><code>Starting app!
Timer: 0
5 seconds have
passed!
Timer: 5197
Actual interval:5197
5 seconds have
passed!
Timer: 10397
Actual interval:5195
5 seconds have
passed!
Timer: 15597
Actual interval:5194
5 seconds have
passed!
Timer: 20802
Actual interval:5200
5 seconds have
passed!
Timer: 25998
Actual interval:5192
5 seconds have
passed!
Timer: 31193
Actual interval:5190
5 seconds have
passed!
Timer: 36388
Actual interval:5189
5 seconds have
passed!
Timer: 41587
Actual interval:5194
</code></pre>
          <p>As you can see, on my computer, the accuracy of the intervals is about off by a little under 200 milliseconds -- one-fifth of a second. This shouldn't be a surprise, as we determined in the previous exercise that on my computer, the <code>main_app_loop</code> handler gets called 5 times a second.</p>
          <p>For many apps, being off by a fifth of a second isn't a problem. But let's suppose we want this app to be more accurate. We can do this by reducing the value of <code>INTERVAL_LENGTH_MS</code>. Looking at the console output above and doing a little math, we find that the average actual interval is 5193 milliseconds, or 193 milliseconds longer than our desired interval length. If we subtract 193 from <code>INTERVAL_LENGTH_MS</code>, changing its value to 4807, the app becomes considerably more accurate. Here's the console output for this case:</p>
<pre><code>Starting app!
Timer: 0
5 seconds have
passed!
Timer: 4994
Actual interval:4994
5 seconds have
passed!
Timer: 9992
Actual interval:4993
5 seconds have
passed!
Timer: 14986
Actual interval:4988
5 seconds have
passed!
Timer: 19986
Actual interval:4996
5 seconds have
passed!
Timer: 24989
Actual interval:4999
5 seconds have
passed!
Timer: 29988
Actual interval:4994
5 seconds have
passed!
Timer: 34986
Actual interval:4994
5 seconds have
passed!
Timer: 39984
Actual interval:4994
</code></pre>
          <p>With this single adjustment, the average interval is within 6 milliseconds of our target interval of 5 seconds. That's pretty good; 6 milliseconds is approximately the time it takes sound to travel 6 feet.</p>
          
          <h3>At Last, The Magic 8-Ball</h3>
          <p>We now have enough inPulse programming know-how to code a "Magic 8-Ball" app. It should do the following:</p>
          <ul>
            <li>It should normally display the current time, showing the hour, minutes and seconds.</li>
            <li>When the user presses the button down, the display should read <strong>Think of a yes-or-no question.</strong></li>
            <li>When the user releases the button, the display should show a "Magic 8-Ball" answer for 5 seconds, then return to its normal display of the current time.
          </ul>
          <p>Here's the code for this app:</p>
          <p><a href="https://github.com/AccordionGuy/inpulse-magic-8-ball/blob/master/inpulse_magic_8_ball.c"><strong><em>inpulse_magic_8_ball.c</em></strong></a></p>
<pre><code>//
// InPulse Magic 8-Ball
// ====================
//
// A "Magic 8-ball" app for the inPulse smartwatch.
// Normally, it displays the time in h:mm:ss format.
// When the user presses the button, it displays
// a "Magic 8-ball"-style answer for five seconds,
// and then returns to its normal mode of showing
// the time.

#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;pulse_os.h&gt;
#include &lt;pulse_types.h&gt;


enum DisplayMode_t { TIME_MODE, ANSWER_MODE } display_mode;

// Magic 8-ball answers
#define  NUM_8BALL_ANSWERS 15
typedef  char* string;
string   magic_8ball_quotes[NUM_8BALL_ANSWERS];

// Timing
#define  TIME_UPDATE_INTERVAL_LENGTH_MS 900
#define  ANSWER_INTERVAL_LENGTH_MS 5000 
struct   pulse_time_tm current_time;
uint32_t interval_start_time_ms;
uint32_t interval_length_ms;
uint32_t now_ms;


void initialize_8ball_answers()
{
    magic_8ball_quotes[0]  = "I'd bet money on it";
    magic_8ball_quotes[1]  = "HELLZ YEAH!";
    magic_8ball_quotes[2]  = "Yes. Absolutely.";
    magic_8ball_quotes[3]  = "Signs point to yes.";
    magic_8ball_quotes[4]  = "Without a doubt.";
    magic_8ball_quotes[5]  = "Ask again later.";
    magic_8ball_quotes[6]  = "I'm not sure; try again.";
    magic_8ball_quotes[7]  = "Mmmmmmmmmaybe.";
    magic_8ball_quotes[8]  = "Think and ask again.";
    magic_8ball_quotes[9]  = "Can't predict now.";
    magic_8ball_quotes[10] = "Ummm...no.";
    magic_8ball_quotes[11] = "HELLZ NO!";
    magic_8ball_quotes[12] = "Absolutely not!";
    magic_8ball_quotes[13] = "I seriously doubt it.";
    magic_8ball_quotes[14] = "No. No. No. NO!";
}

string random_magic_8ball_quote()
{
    return magic_8ball_quotes[rand() % NUM_8BALL_ANSWERS];
}

void set_time_mode()
{
    display_mode = TIME_MODE;
    interval_length_ms = TIME_UPDATE_INTERVAL_LENGTH_MS;
    interval_start_time_ms = pulse_get_millis();
}

void update_time_display()
{
    pulse_blank_canvas();
    pulse_get_time_date(&current_time);
    printf("The time is\n%d:%0.2d:%0.2d\n", 
           current_time.tm_hour,
           current_time.tm_min,
           current_time.tm_sec);
}

void display_prequote_message()
{
    pulse_blank_canvas();
    printf("Think of a yes-\nor-no question.\n");
}

void set_answer_mode()
{
    display_mode = ANSWER_MODE;
    interval_length_ms = ANSWER_INTERVAL_LENGTH_MS;
    interval_start_time_ms = pulse_get_millis();
}

void display_answer()
{
    pulse_blank_canvas();
    printf("The 8-ball says:\n\"%s\"\n", random_magic_8ball_quote());
}


// inPulse Event Handlers
// ======================

void main_app_init()
{
    initialize_8ball_answers();
    set_time_mode();
    update_time_display();
}

void main_app_handle_button_down()
{
    display_prequote_message();
}

void main_app_handle_button_up()
{
    set_answer_mode();
    display_answer();
}

void main_app_loop()
{
    now_ms = pulse_get_millis();
    if (now_ms - interval_start_time_ms > interval_length_ms) {
        if (display_mode == ANSWER_MODE) {
            set_time_mode();
        }
        update_time_display();
    }
}

void main_app_handle_doz()
{

}

void main_app_handle_hardware_update(enum PulseHardwareEvent event)
{

}</code></pre>
          <p>Most of the time, the app is in "time mode", where it looks like this:</p>
          <p><img src="images/simulator_12.jpg"></p>
          <p>In time mode, the app displays the current time. The time interval when we check to see if it's time to update the display is set to 900 milliseconds, just below a full second. In <code>main_app_loop</code>, we check to see if we've been waiting longer than that interval. If that's the case, it means that nearly a second has passed and it's time to update the time display, which we do in <code>update_time_display</code>.</p>
          <p>When the user presses and releases the button, the app is put in "answer mode" (with <code>set_answer_mode</code>), which looks like this:</p>
          <p><img src="images/simulator_13.jpg"></p>
          <p>In answer mode, the app displays a random "Magic 8-ball" answer for 5 seconds (<code>display_answer</code>), after which it returns to time mode. The time interval when we check to see if it's time to switch back to time mode is set to 5000 milliseconds, which is 5 seconds. In <code>main_app_loop</code>, we check to see if we've been waiting longer than that interval. If that's the case, it means that 5 seconds have passed and it's time to change to time mode (<code>set_time_mode</code>) and then display the time (<code>update_time_display</code>).</p>
          
        </section>

        <footer>
          Inpulse-magic-8-ball is maintained by <a href="https://github.com/AccordionGuy">AccordionGuy</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="http://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>